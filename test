能否将下面代码中的注释从中文替换为英文
import os 
import time
import json
from flask import Flask, request, jsonify
from dotenv import dotenv_values
from azure.cosmos import CosmosClient, PartitionKey
import pandas as pd
import numpy as np
from openai import AzureOpenAI

app = Flask(__name__)

# 加载环境变量 
env_name = os.path.join(os.path.dirname(__file__), "variable.env")
config = dotenv_values(env_name)

# CosmosDB配置
NOSQL_URI = config["NOSQL_URI"]
COSMOS_KEY = config['NOSQL_PRIMARY_KEY']
DATABASE_NAME = "ipc-test-db"
CONTAINER_NAME = "ipc-test-cont"

# Azure OpenAI配置
openai_endpoint = config['AOAI_ENDPOINT']
openai_key = config['AOAI_KEY']
openai_api_version = config['API_VERSION']
openai_embeddings_deployment = config['AOAI_EMBEDDING_DEPLOYMENT']
openai_embeddings_model = config['AOAI_EMBEDDING_DEPLOYMENT_MODEL']

API_KEY = config.get("API_KEY", "1145141919810")  # 从环境变量获取API密钥

def generate_ipc_embeddings(description):
    """生成文本的向量嵌入"""
    try:
        azure_openai_embeddings = AzureOpenAI(
            api_version=openai_api_version,
            api_key=openai_key,
            azure_endpoint=openai_endpoint,
        )
        response = azure_openai_embeddings.embeddings.create(
           input=description,
           model=openai_embeddings_model
        )
        embeddings = response.model_dump()
        time.sleep(0.5)  # 避免API频率限制
        return embeddings['data'][0]['embedding']
    except Exception as e:
        app.logger.error(f"Embedding generation error: {e}")
        return None

def vector_search(current_description_vector, num_results=10, filter_class=None, filter_subclass=None):
    """在CosmosDB中执行向量搜索"""
    try:
        # 初始化CosmosDB客户端
        cosmos_client = CosmosClient(url=NOSQL_URI, credential=COSMOS_KEY)
        db = cosmos_client.get_database_client(DATABASE_NAME)
        container = db.get_container_client(CONTAINER_NAME)
        
        if isinstance(current_description_vector, np.ndarray):
            current_description_vector = current_description_vector.tolist()
        
        sql_query = """ 
        SELECT TOP @num_results 
            c.id, c.class, c.subclass, c.ja_description, c.en_description, 
            VectorDistance(c.descriptionVector, @current_description_vector) AS DescriptionDist 
        FROM c 
        WHERE 1=1 
        """
        
        parameters = [
            {"name": "@current_description_vector", "value": current_description_vector},
            {"name": "@num_results", "value": num_results}
        ]
        
        if filter_class:
            sql_query += " AND ARRAY_CONTAINS(@filter_class, c.class) "
            parameters.append({
                "name": "@filter_class", 
                "value": filter_class
            })
        
        if filter_subclass:
            sql_query += " AND ARRAY_CONTAINS(@filter_subclass, c.subclass) "
            parameters.append({
                "name": "@filter_subclass", 
                "value": filter_subclass
            })
        
        sql_query += """ 
        ORDER BY VectorDistance(c.descriptionVector, @current_description_vector) 
        """
        
        results = container.query_items(
            query=sql_query, 
            parameters=parameters, 
            enable_cross_partition_query=True
        )
        
        return list(results)
    except Exception as e:
        app.logger.error(f"Vector search error: {e}")
        return []

def perform_search(description, filter_class=None, filter_subclass=None):
    """执行搜索并返回结果"""
    current_description_vector = generate_ipc_embeddings(description)
    
    if current_description_vector is None:
        return "Error: Unable to generate description embeddings.", None
    
    results = vector_search(
        current_description_vector, 
        num_results=10, 
        filter_class=filter_class,
        filter_subclass=filter_subclass
    )
    
    if not results or len(results) == 0:
        return "Error: No results found from the vector search.", None
    
    return "Search successful", results

@app.route('/retrieval', methods=['POST'])
def retrieve_data():
    """处理检索请求的路由"""
    # 验证Authorization头
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Unauthorized access"}), 403
    
    # 提取API Key
    api_key = auth_header.split(' ')[1]
    
    # 检查 API Key 是否匹配
    if api_key != API_KEY:
        return jsonify({"error": "Invalid API Key"}), 403

    # 获取请求体中的 JSON 数据
    data = request.get_json()

    query = data.get('query')
    if not query:
        return jsonify({"error": "Query parameter is missing"}), 400

    retrieval_setting = data.get('retrieval_setting', {})
    top_k = retrieval_setting.get('top_k', 5)
    score_threshold = retrieval_setting.get('score_threshold', 0.5)

    # 确保 Top K 和分数阈值为整数和浮点数
    try:
        top_k = int(top_k)
        score_threshold = float(score_threshold)
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid top_k or score_threshold"}), 400

    # 执行向量搜索
    verdict, results = perform_search(query)

    if verdict != "Search successful":
        return jsonify({"error": verdict}), 404

    # 过滤并限制结果
    filtered_results = [
        result for result in results 
        if result.get('DescriptionDist', 1.0) <= (1 - score_threshold)
    ][:top_k]

    # 构建符合dify接口要求的返回结构
    records = []
    for result in filtered_results:
        record = {
            "metadata": {
                "path": f"ipc://{result['id']}",
                "description": result.get('en_description', 'No English description')
            },
            "score": 1 - result.get('DescriptionDist', 1.0),
            "title": f"IPC Class: {result.get('class', 'N/A')} Subclass: {result.get('subclass', 'N/A')}",
            "content": result.get('ja_description', 'No Japanese description')
        }
        records.append(record)

    return jsonify({"records": records})

@app.route('/health', methods=['GET'])
def health_check():
    """健康检查端点"""
    return jsonify({
        "status": "healthy", 
        "database": "connected" if test_database_connection() else "disconnected",
        "openai": "connected" if test_openai_connection() else "disconnected"
    }), 200

def test_database_connection():
    """测试数据库连接"""
    try:
        cosmos_client = CosmosClient(url=NOSQL_URI, credential=COSMOS_KEY)
        db = cosmos_client.get_database_client(DATABASE_NAME)
        db.read()
        return True
    except Exception as e:
        app.logger.error(f"Database connection error: {e}")
        return False

def test_openai_connection():
    """测试OpenAI连接"""
    try:
        azure_openai_embeddings = AzureOpenAI(
            api_version=openai_api_version,
            api_key=openai_key,
            azure_endpoint=openai_endpoint,
        )
        azure_openai_embeddings.embeddings.create(
           input="Test connection",
           model=openai_embeddings_model
        )
        return True
    except Exception as e:
        app.logger.error(f"OpenAI connection error: {e}")
        return False

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=6666, debug=True)
